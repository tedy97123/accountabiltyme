-- AccountabilityMe Ledger - PostgreSQL Schema v1.1
-- 
-- This schema implements the immutable append-only event log.
-- Two tables: ledger_head (single row for chain state) and ledger_events (the log).
--
-- CRITICAL: Never modify or delete rows in ledger_events.
-- The triggers below enforce immutability at the database level.
--
-- CHANGES FROM v1.0:
-- - Added spec_version column for multi-version support
-- - Strengthened constraints (NOT NULL where appropriate)
-- - Added explicit hash format validation

-- ============================================================
-- EXTENSIONS
-- ============================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================
-- LEDGER HEAD TABLE
-- Single row that tracks the current chain state.
-- This is the lock target for atomic appends (FOR UPDATE).
-- ============================================================

CREATE TABLE IF NOT EXISTS ledger_head (
    -- Single row enforced: only TRUE allowed, and it's the PK
    id BOOLEAN PRIMARY KEY DEFAULT TRUE CHECK (id IS TRUE),
    
    -- Last assigned sequence number (-1 means empty ledger)
    last_sequence BIGINT NOT NULL DEFAULT -1,
    
    -- Hash of the last event (NULL means empty ledger)
    -- When non-NULL, must be valid SHA-256 hex (64 chars)
    last_event_hash VARCHAR(64) DEFAULT NULL,
    
    -- Timestamps for auditing
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Validate hash format when present
    CONSTRAINT valid_head_hash_format CHECK (
        last_event_hash IS NULL OR last_event_hash ~ '^[a-f0-9]{64}$'
    ),
    
    -- Consistency: -1 sequence means NULL hash, otherwise hash required
    CONSTRAINT head_sequence_hash_consistency CHECK (
        (last_sequence = -1 AND last_event_hash IS NULL) OR
        (last_sequence >= 0 AND last_event_hash IS NOT NULL)
    )
);

-- Initialize with empty state (idempotent)
INSERT INTO ledger_head (id, last_sequence, last_event_hash)
VALUES (TRUE, -1, NULL)
ON CONFLICT (id) DO NOTHING;

-- ============================================================
-- LEDGER EVENTS TABLE
-- The immutable append-only event log.
-- ============================================================

CREATE TABLE IF NOT EXISTS ledger_events (
    -- Primary key: event UUID (generated by application)
    event_id UUID PRIMARY KEY,
    
    -- Sequence number: monotonically increasing (0, 1, 2, ...)
    -- UNIQUE constraint prevents duplicate sequence numbers
    sequence_number BIGINT NOT NULL UNIQUE,
    
    -- Chain linkage
    -- NULL only for genesis (sequence_number = 0)
    -- Required for all other events
    previous_event_hash VARCHAR(64),
    event_hash VARCHAR(64) NOT NULL UNIQUE,
    
    -- Event metadata
    event_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    
    -- Editorial attribution
    created_by UUID NOT NULL,
    editor_signature TEXT NOT NULL,
    
    -- Timestamp (application-provided, NOT NULL)
    created_at TIMESTAMPTZ NOT NULL,
    
    -- Payload storage
    -- Store both original JSON and canonical form for verification
    payload_json JSONB NOT NULL,
    payload_canon TEXT NOT NULL,
    
    -- Versioning for forward compatibility
    -- canon_version: which canonicalization rules were used
    -- spec_version: which spec version this event conforms to
    canon_version INTEGER NOT NULL DEFAULT 1,
    spec_version VARCHAR(20) NOT NULL DEFAULT '1.0',
    
    -- Anchoring fields (populated after anchoring)
    anchor_batch_id UUID DEFAULT NULL,
    merkle_proof JSONB DEFAULT NULL,  -- Array of proof hashes as JSON
    
    -- ============================================================
    -- CONSTRAINTS: Defense in depth (matches LedgerService rules)
    -- ============================================================
    
    -- Genesis rule: seq 0 has no previous, all others require it
    CONSTRAINT valid_genesis_rule CHECK (
        (sequence_number = 0 AND previous_event_hash IS NULL) OR
        (sequence_number > 0 AND previous_event_hash IS NOT NULL)
    ),
    
    -- Hash format: SHA-256 = 64 lowercase hex characters
    CONSTRAINT valid_event_hash_format CHECK (
        event_hash ~ '^[a-f0-9]{64}$'
    ),
    
    CONSTRAINT valid_previous_hash_format CHECK (
        previous_event_hash IS NULL OR previous_event_hash ~ '^[a-f0-9]{64}$'
    ),
    
    -- Sequence must be non-negative
    CONSTRAINT valid_sequence_number CHECK (
        sequence_number >= 0
    ),
    
    -- Canon version must be positive
    CONSTRAINT valid_canon_version CHECK (
        canon_version > 0
    )
);

-- ============================================================
-- INDEXES
-- ============================================================

-- Primary access pattern: ordered retrieval
CREATE INDEX IF NOT EXISTS idx_ledger_events_sequence 
    ON ledger_events (sequence_number);

-- Entity lookups (claims, editors, evidence)
CREATE INDEX IF NOT EXISTS idx_ledger_events_entity 
    ON ledger_events (entity_id, sequence_number);

-- Event type filtering
CREATE INDEX IF NOT EXISTS idx_ledger_events_type 
    ON ledger_events (event_type);

-- Editor activity tracking
CREATE INDEX IF NOT EXISTS idx_ledger_events_editor 
    ON ledger_events (created_by);

-- Spec version filtering (for migrations/upgrades)
CREATE INDEX IF NOT EXISTS idx_ledger_events_spec_version
    ON ledger_events (spec_version);

-- ============================================================
-- IMMUTABILITY TRIGGERS
-- These prevent UPDATE and DELETE on ledger_events.
-- Even with DB access, you cannot tamper.
-- ============================================================

-- Function to prevent updates
CREATE OR REPLACE FUNCTION prevent_event_update()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 
        'IMMUTABILITY VIOLATION: ledger_events cannot be updated. '
        'Event ID: %, Sequence: %. '
        'The ledger is append-only.',
        OLD.event_id, OLD.sequence_number
        USING ERRCODE = 'integrity_constraint_violation';
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to prevent deletes
CREATE OR REPLACE FUNCTION prevent_event_delete()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 
        'IMMUTABILITY VIOLATION: ledger_events cannot be deleted. '
        'Event ID: %, Sequence: %. '
        'The ledger is append-only.',
        OLD.event_id, OLD.sequence_number
        USING ERRCODE = 'integrity_constraint_violation';
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Apply immutability triggers
DROP TRIGGER IF EXISTS prevent_event_update_trigger ON ledger_events;
CREATE TRIGGER prevent_event_update_trigger
    BEFORE UPDATE ON ledger_events
    FOR EACH ROW
    EXECUTE FUNCTION prevent_event_update();

DROP TRIGGER IF EXISTS prevent_event_delete_trigger ON ledger_events;
CREATE TRIGGER prevent_event_delete_trigger
    BEFORE DELETE ON ledger_events
    FOR EACH ROW
    EXECUTE FUNCTION prevent_event_delete();

-- ============================================================
-- LEDGER HEAD UPDATE TRIGGER
-- Automatically update the updated_at timestamp.
-- ============================================================

CREATE OR REPLACE FUNCTION update_ledger_head_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS ledger_head_timestamp_trigger ON ledger_head;
CREATE TRIGGER ledger_head_timestamp_trigger
    BEFORE UPDATE ON ledger_head
    FOR EACH ROW
    EXECUTE FUNCTION update_ledger_head_timestamp();

-- ============================================================
-- SEQUENCE CONTINUITY (via ledger_head lock + UNIQUE constraint)
-- ============================================================
-- NOTE: The enforce_sequence_continuity() trigger was REMOVED for performance.
-- 
-- REASON: The trigger did MAX(sequence_number) on every insert, which:
--   1. Creates a hotspot under concurrent writes
--   2. Can cause deadlock-like contention
--   3. Is redundant with existing protections
--
-- EXISTING PROTECTIONS (sufficient for integrity):
--   1. ledger_head FOR UPDATE lock serializes all writers
--   2. UNIQUE(sequence_number) prevents duplicates at DB level
--   3. Application code validates sequence before commit
--   4. Chain linkage (previous_event_hash) provides cryptographic ordering
--
-- If you REALLY want DB-level defense-in-depth without the MAX scan,
-- you could validate against ledger_head.last_sequence + 1 in a trigger,
-- but since we update head in the same transaction, it's tricky and
-- still adds contention. The head lock + UNIQUE is enough.
--
-- DROP existing trigger if present (for migrations)
DROP TRIGGER IF EXISTS enforce_sequence_continuity_trigger ON ledger_events;
DROP FUNCTION IF EXISTS enforce_sequence_continuity();

-- ============================================================
-- HELPER VIEWS
-- ============================================================

-- View for chain integrity verification
CREATE OR REPLACE VIEW ledger_chain_view AS
SELECT 
    sequence_number,
    event_id,
    event_type,
    entity_id,
    previous_event_hash,
    event_hash,
    created_at,
    spec_version,
    LAG(event_hash) OVER (ORDER BY sequence_number) AS expected_previous_hash,
    CASE 
        WHEN sequence_number = 0 AND previous_event_hash IS NULL THEN TRUE
        WHEN sequence_number > 0 AND previous_event_hash = LAG(event_hash) OVER (ORDER BY sequence_number) THEN TRUE
        ELSE FALSE
    END AS chain_valid
FROM ledger_events
ORDER BY sequence_number;

-- View for latest state summary
CREATE OR REPLACE VIEW ledger_status_view AS
SELECT 
    h.last_sequence + 1 AS event_count,
    h.last_event_hash AS chain_head,
    h.updated_at AS last_append_at,
    (SELECT COUNT(DISTINCT entity_id) FROM ledger_events WHERE entity_type = 'claim') AS claim_count,
    (SELECT COUNT(DISTINCT entity_id) FROM ledger_events WHERE entity_type = 'editor') AS editor_count,
    (SELECT COUNT(DISTINCT spec_version) FROM ledger_events) AS spec_versions_in_use
FROM ledger_head h
WHERE h.id = TRUE;

-- ============================================================
-- MIGRATION HELPER (for existing v1.0 tables)
-- Run this if upgrading from schema v1.0
-- ============================================================

-- Add spec_version column if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'ledger_events' AND column_name = 'spec_version'
    ) THEN
        ALTER TABLE ledger_events 
        ADD COLUMN spec_version VARCHAR(20) NOT NULL DEFAULT '1.0';
        
        CREATE INDEX IF NOT EXISTS idx_ledger_events_spec_version
            ON ledger_events (spec_version);
            
        RAISE NOTICE 'Added spec_version column to ledger_events';
    END IF;
END $$;

-- Migrate merkle_proof from TEXT[] to JSONB (if upgrading from old schema)
-- NOTE: TEXT[]::text produces Postgres array literal {"a","b"} which is NOT valid JSON.
-- We must use to_jsonb() for proper conversion.
DO $$
BEGIN
    -- Check if merkle_proof is still TEXT[] type
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'ledger_events' 
        AND column_name = 'merkle_proof'
        AND data_type = 'ARRAY'
    ) THEN
        ALTER TABLE ledger_events 
        ALTER COLUMN merkle_proof TYPE JSONB 
        USING to_jsonb(merkle_proof);
        
        RAISE NOTICE 'Migrated merkle_proof from TEXT[] to JSONB';
    END IF;
END $$;

-- ============================================================
-- READ MODEL TABLES (Phase 2 - Optional Projections)
-- These are caches, rebuildable from events.
-- Uncomment when ready for read-model optimization.
-- ============================================================

/*
-- Editors projection (for fast lookups)
CREATE TABLE IF NOT EXISTS editors_projection (
    editor_id UUID PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,
    display_name VARCHAR(200) NOT NULL,
    role VARCHAR(50) NOT NULL,
    public_key TEXT NOT NULL UNIQUE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    registered_at TIMESTAMPTZ NOT NULL,
    registered_by UUID,
    deactivated_at TIMESTAMPTZ,
    last_event_sequence BIGINT NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Claims projection (for fast lookups)
CREATE TABLE IF NOT EXISTS claims_projection (
    claim_id UUID PRIMARY KEY,
    reference_id VARCHAR(50) UNIQUE,
    claimant_id UUID NOT NULL,
    statement TEXT NOT NULL,
    status VARCHAR(50) NOT NULL,
    declared_at TIMESTAMPTZ NOT NULL,
    operationalized_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    resolution VARCHAR(50),
    evidence_count INTEGER NOT NULL DEFAULT 0,
    last_event_sequence BIGINT NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_claims_status ON claims_projection (status);
CREATE INDEX IF NOT EXISTS idx_claims_claimant ON claims_projection (claimant_id);
*/

-- ============================================================
-- GRANTS (adjust for your user/role setup)
-- ============================================================

-- Example: Grant access to application user
-- GRANT SELECT, INSERT ON ledger_events TO app_user;
-- GRANT SELECT, UPDATE ON ledger_head TO app_user;
-- GRANT SELECT ON ledger_chain_view, ledger_status_view TO app_user;

-- ============================================================
-- SECURITY NOTE
-- ============================================================
-- 
-- There is NO "ON CONFLICT DO UPDATE" anywhere in this schema.
-- The only ON CONFLICT is "DO NOTHING" for ledger_head initialization.
-- This is intentional: the ledger is append-only.
--
-- grep -r "ON CONFLICT" to verify: only DO NOTHING should appear.
-- ============================================================
