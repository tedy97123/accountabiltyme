# Accountability Ledger Protocol Specification

**Version:** 1.0.0  
**Status:** Draft  
**Last Updated:** 2026-01-11

---

## Abstract

The Accountability Ledger Protocol (ALP) defines a standard format for recording, chaining, signing, and verifying claims and their outcomes. It enables independent verification of claim integrity without trusting any central authority.

This specification defines:
1. Canonical serialization rules
2. Event structure and types
3. Hash chaining rules
4. Digital signature requirements
5. Merkle anchoring proof format
6. Verification procedures

---

## 1. Terms and Conventions

The key words "MUST", "SHOULD", "MAY", "MUST NOT", and "SHOULD NOT" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

- **Event**: An immutable record of something that happened
- **Chain**: A sequence of events linked by cryptographic hashes
- **Editor**: An identity that can create and sign events
- **Claim**: A statement that can be operationalized, evidenced, and resolved
- **Bundle**: A self-contained, verifiable export of a claim and its events

---

## 2. Canonical Serialization

All data structures MUST be serialized to canonical JSON before hashing. This ensures deterministic, reproducible hashes across implementations.

### 2.1 Canonicalization Rules

The canonical format is versioned. The current version is `1`.

**Rule 2.1.1**: The serialized output MUST include a `__canon_v` field with the serialization version.

**Rule 2.1.2**: Dictionary keys MUST be sorted in Unicode codepoint order (ascending).

**Rule 2.1.3**: JSON serialization MUST use:
- `separators=(",", ":")` (no whitespace)
- `ensure_ascii=true` (non-ASCII escaped as `\uXXXX`)
- `allow_nan=false` (NaN/Infinity rejected)

**Rule 2.1.4**: Data types MUST be serialized as follows:

| Type | Serialization | Example |
|------|--------------|---------|
| `null` | `null` | `null` |
| `boolean` | `true` or `false` | `true` |
| `string` | JSON string | `"hello"` |
| `integer` | JSON number | `42` |
| `Decimal` | String representation | `"3.14159"` |
| `UUID` | Lowercase string | `"a1b2c3d4-e5f6-..."` |
| `datetime` | ISO 8601 UTC with Z | `"2026-01-11T12:00:00.000000Z"` |
| `Enum` | `.value` string | `"CLAIM_DECLARED"` |
| `list` | JSON array | `[1, 2, 3]` |
| `dict` | JSON object (keys sorted) | `{"a":1,"b":2}` |

**Rule 2.1.5**: Floats MUST NOT be used in canonical payloads. Use `Decimal` as string.

**Rule 2.1.6**: `None`/`null` values MUST be omitted from the canonical output.

**Rule 2.1.7**: Datetime values MUST be timezone-aware and normalized to UTC with exactly 6 microsecond digits.

### 2.2 Example Canonical Output

Input:
```json
{
  "claim_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "amount": 3.14159,
  "active": true,
  "tags": ["policy", "housing"]
}
```

Canonical output (version 1):
```json
{"__canon_v":1,"active":true,"amount":"3.14159","claim_id":"a1b2c3d4-e5f6-7890-abcd-ef1234567890","tags":["policy","housing"]}
```

---

## 3. Event Structure

### 3.1 Event Fields

Every event MUST contain the following fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `event_id` | UUID | MUST | Unique identifier for this event |
| `sequence_number` | integer | MUST | Monotonically increasing (0 for genesis) |
| `event_type` | string | MUST | Type of event (see §3.2) |
| `entity_id` | UUID | MUST | The claim/entity this event affects |
| `entity_type` | string | MUST | Type: "claim", "editor", "evidence" |
| `payload` | object | MUST | Event-specific data |
| `previous_event_hash` | string | CONDITIONAL | Hash of previous event (see §4) |
| `event_hash` | string | MUST | SHA-256 hash of this event |
| `created_by` | UUID | MUST | Editor who created this event |
| `editor_signature` | string | MUST | Ed25519 signature |
| `created_at` | datetime | MUST | UTC timestamp |
| `anchor_batch_id` | UUID | MAY | Merkle anchor batch ID |
| `merkle_proof` | array | MAY | Merkle proof hashes |

### 3.2 Event Types

| Event Type | Description |
|------------|-------------|
| `EDITOR_REGISTERED` | An editor identity was created |
| `EDITOR_DEACTIVATED` | An editor was deactivated |
| `CLAIM_DECLARED` | A claim was recorded |
| `CLAIM_OPERATIONALIZED` | A claim was made testable |
| `EVIDENCE_ADDED` | Evidence was attached to a claim |
| `CLAIM_RESOLVED` | A claim was resolved |

### 3.3 Payload Schemas

#### 3.3.1 EDITOR_REGISTERED

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `editor_id` | UUID | MUST | Editor's unique ID |
| `username` | string | MUST | Unique username (min 3 chars) |
| `display_name` | string | MUST | Display name |
| `role` | string | MUST | "admin", "senior", "editor", "reviewer" |
| `public_key` | string | MUST | Ed25519 public key (base64) |
| `registered_by` | UUID | MAY | Registering editor (null for genesis) |
| `registration_rationale` | string | MUST | Reason for registration (min 10 chars) |

#### 3.3.2 CLAIM_DECLARED

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `claim_id` | UUID | MUST | Claim's unique ID |
| `claimant_id` | UUID | MUST | Who made the claim |
| `statement` | string | MUST | The claim text (min 10 chars) |
| `statement_context` | string | MAY | Context where claim was made |
| `declared_at` | datetime | MUST | When claim was made |
| `source_url` | string | MAY | Source URL |
| `claim_type` | string | MUST | "predictive", "descriptive", "causal" |
| `scope` | object | MAY | Geographic/domain scope |

#### 3.3.3 CLAIM_OPERATIONALIZED

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `claim_id` | UUID | MUST | Claim being operationalized |
| `expected_outcome` | object | MUST | What should happen |
| `timeframe` | object | MUST | When to evaluate |
| `evaluation_criteria` | object | MUST | Success/failure conditions |
| `operationalization_notes` | string | MAY | Additional notes |

#### 3.3.4 EVIDENCE_ADDED

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `evidence_id` | UUID | MUST | Evidence unique ID |
| `claim_id` | UUID | MUST | Claim this evidence relates to |
| `source_url` | string | MUST | Evidence source URL |
| `source_title` | string | MUST | Source title |
| `source_type` | string | MUST | "primary", "secondary" |
| `evidence_type` | string | MUST | Type of evidence |
| `summary` | string | MUST | Evidence summary (min 10 chars) |
| `supports_claim` | boolean | MUST | Does evidence support claim? |
| `confidence_score` | string | MUST | 0-1 as decimal string |

#### 3.3.5 CLAIM_RESOLVED

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `claim_id` | UUID | MUST | Claim being resolved |
| `resolution` | string | MUST | "met", "partially_met", "not_met", "inconclusive" |
| `resolution_summary` | string | MUST | Explanation (min 20 chars) |
| `supporting_evidence_ids` | array | MUST | Evidence UUIDs (min 1 for non-inconclusive) |

---

## 4. Hash Chaining

### 4.1 Chain Rules

**Rule 4.1.1**: The genesis event (sequence_number = 0) MUST have `previous_event_hash = null`.

**Rule 4.1.2**: All non-genesis events MUST have `previous_event_hash` set to the `event_hash` of the immediately preceding event.

**Rule 4.1.3**: `sequence_number` MUST be monotonically increasing: 0, 1, 2, ...

**Rule 4.1.4**: Events MUST NOT be inserted, deleted, or reordered after creation.

### 4.2 Hash Computation

The event hash is computed as:

```
event_hash = SHA256(previous_event_hash + ":" + canonical_payload)
```

Where:
- `previous_event_hash` is the hex-encoded hash of the previous event (or empty string for genesis)
- `canonical_payload` is the canonicalized JSON of the event payload
- `SHA256` produces a lowercase hex-encoded 64-character string

### 4.3 Hash Validation

To validate an event hash:

1. Canonicalize the payload using the rules in §2
2. Construct the hash input: `{previous_hash}:{canonical_payload}`
3. Compute SHA-256 of the input
4. Compare with stored `event_hash` (case-insensitive)

---

## 5. Digital Signatures

### 5.1 Signature Algorithm

All signatures MUST use Ed25519 ([RFC 8032](https://www.rfc-editor.org/rfc/rfc8032)).

### 5.2 What is Signed

**Rule 5.2.1**: The `editor_signature` MUST be an Ed25519 signature of the `event_hash` bytes.

**Rule 5.2.2**: The signature MUST be base64 encoded.

### 5.3 Signature Verification

To verify a signature:

1. Decode the `editor_signature` from base64
2. Get the editor's `public_key` from the EDITOR_REGISTERED event
3. Decode the `event_hash` from hex to bytes
4. Verify the Ed25519 signature

### 5.4 Editor Identity Rules

**Rule 5.4.1**: An editor MUST be registered before performing any action.

**Rule 5.4.2**: Editor public keys are IMMUTABLE after registration.

**Rule 5.4.3**: A deactivated editor's past signatures remain valid.

---

## 6. Merkle Anchoring

### 6.1 Anchor Batch

An anchor batch commits a range of events to a single Merkle root.

| Field | Type | Description |
|-------|------|-------------|
| `batch_id` | UUID | Unique batch identifier |
| `merkle_root` | string | Root hash of the Merkle tree |
| `sequence_start` | integer | First event sequence in batch |
| `sequence_end` | integer | Last event sequence in batch |
| `event_hashes` | array | Event hashes in the batch |
| `created_at` | datetime | When batch was created |

### 6.2 Merkle Tree Construction

1. Leaf nodes are the `event_hash` values (in sequence order)
2. If odd number of leaves, duplicate the last leaf
3. Build tree bottom-up: `parent = SHA256(left + right)`
4. Root is the single hash at the top

### 6.3 Merkle Proof Format

A proof is an array of `{hash, direction}` pairs:

```json
{
  "proof_hashes": ["abc123...", "def456..."],
  "proof_directions": ["left", "right"]
}
```

### 6.4 Proof Verification

To verify an event is in an anchor:

1. Start with the event's `event_hash`
2. For each proof step:
   - If direction is "left": `hash = SHA256(proof_hash + current_hash)`
   - If direction is "right": `hash = SHA256(current_hash + proof_hash)`
3. Final hash MUST equal `merkle_root`

---

## 7. Claim Bundle Format

A claim bundle is a JSON document containing everything needed for independent verification.

### 7.1 Bundle Structure

```json
{
  "_meta": {
    "bundle_version": "1.0.0",
    "spec_version": "v1",
    "exported_at": "2026-01-11T12:00:00.000000Z",
    "claim_id": "...",
    "chain_valid_at_export": true
  },
  "_verification": {
    "canonicalization_version": 1,
    "hash_algorithm": "sha256",
    "signature_algorithm": "ed25519",
    "instructions": ["..."]
  },
  "claim": {
    "claim_id": "...",
    "status": "resolved",
    "event_count": 5
  },
  "events": [...],
  "editors": {...}
}
```

### 7.2 Bundle Verification Procedure

A verifier MUST perform these checks:

1. **Hash Verification**: For each event, recompute the event hash and verify it matches.

2. **Chain Linkage**: Verify each event's `previous_event_hash` equals the preceding event's `event_hash`.

3. **Signature Verification**: For each event, verify the `editor_signature` using the editor's `public_key`.

4. **Sequence Continuity**: Verify sequence numbers are consecutive starting from the first event in the bundle.

5. **Editor Validity**: Verify each `created_by` editor was registered before the event.

### 7.3 Verification Result

A verification MUST return one of:

| Result | Meaning |
|--------|---------|
| `VERIFIED` | All checks passed |
| `TAMPERED` | Hash or signature mismatch detected |
| `INCOMPLETE` | Missing required data |
| `INVALID_FORMAT` | Bundle structure invalid |

---

## 8. Security Considerations

### 8.1 Determinism

Implementations MUST ensure canonical serialization produces identical output across platforms, languages, and time.

### 8.2 Key Management

Private keys SHOULD be stored in hardware security modules or secure enclaves in production.

### 8.3 Clock Security

Timestamps are editor-provided and SHOULD NOT be relied upon for security-critical ordering. Use sequence numbers.

### 8.4 Replay Protection

Event IDs and sequence numbers prevent replay attacks within a single ledger.

---

## 9. Conformance

### 9.1 Implementation Requirements

A conforming implementation MUST:

1. Implement canonical serialization as specified in §2
2. Support all event types in §3.2
3. Compute hashes according to §4
4. Verify signatures according to §5
5. Generate and verify bundles according to §7

### 9.2 Verification Requirements

A conforming verifier MUST:

1. Accept bundles in the format specified in §7
2. Perform all verification steps in §7.2
3. Return appropriate results as specified in §7.3

---

## Appendix A: Reference Implementation

The reference implementation is available at:
- Repository: [AccountabilityMe](https://github.com/your-org/accountabilityme)
- Language: Python 3.11+
- Key files:
  - `app/core/hasher.py` - Canonical serialization
  - `app/core/signer.py` - Ed25519 signatures
  - `app/core/ledger.py` - Event chain
  - `app/core/anchor.py` - Merkle trees

---

## Appendix B: Test Vectors

### B.1 Canonical Serialization

**Input:**
```json
{
  "name": "test",
  "count": 42,
  "amount": "3.14",
  "active": true,
  "tags": ["a", "b"]
}
```

**Expected Canonical Output:**
```
{"__canon_v":1,"active":true,"amount":"3.14","count":42,"name":"test","tags":["a","b"]}
```

**Expected SHA-256 Hash:**
```
(Run reference implementation to generate)
```

### B.2 Hash Chain

For genesis event with payload `{"claim_id": "..."}`:
```
previous_hash: (empty string)
canonical_payload: {"__canon_v":1,"claim_id":"..."}
hash_input: :{"__canon_v":1,"claim_id":"..."}
event_hash: SHA256(hash_input)
```

For subsequent event:
```
previous_hash: (previous event's event_hash)
hash_input: {previous_hash}:{canonical_payload}
event_hash: SHA256(hash_input)
```

---

## Appendix C: Changelog

### Version 1.0.0 (2026-01-11)
- Initial specification release
- Defines canonical serialization v1
- Defines core event types
- Defines hash chaining rules
- Defines signature requirements
- Defines bundle format

---

## License

This specification is released under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).

